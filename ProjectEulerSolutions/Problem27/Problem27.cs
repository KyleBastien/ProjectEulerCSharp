using System;
namespace Problem27
{
    class Problem27
    {
        private static int[] _primes;

        static void Main()
        {
            // Euler discovered the remarkable quadratic formula:
            //
            // n² + n + 41
            //
            // It turns out that the formula will produce 40 primes for the consecutive values n = 0 to 39. However, when n = 40, 40^2 + 40 + 41 = 40(40 + 1) + 41 is divisible by 41, and certainly when n = 41, 41^2 
            // + 41 + 41 is clearly divisible by 41.
            //
            // The incredible formula  n^2 − 79n + 1601 was discovered, which produces 80 primes for the consecutive values n = 0 to 79. The product of the coefficients, −79 and 1601, is −126479.
            //
            // Considering quadratics of the form:
            //
            // n^2 + an + b, where |a| < 1000 and |b| < 1000
            //
            // where |n| is the modulus/absolute value of n
            // e.g. |11| = 11 and |−4| = 4
            // Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n = 0.
            //
            // First I know that I'm going to need a IsPrime function to check if a number is Prime, so head over to the IsPrime function to check that out.
            //
            // With the IsPrime function it's actually relatively easy to write a Brute Force solution to this, but of course we can do better!
            // 
            // Were going to shrink our solution space, the space that we are searching through, by applying the quadratic formula. The quadratic formula has to provide us with primes all the way from n = 0. What
            // that means is that at n = 0.
            //
            // n^2 + an + b = b
            //
            // And thus b has to be a prime. That limits b from 2001 possibilities to 336. Or a factor 6 reduction in size.
            //
            // For n = 1 we have that:
            //
            // n^2 + an + b = 1 + a + b
            //
            // We know that all primes except for 2 are odd. That means if 1 + a + b has to be odd, a has to be odd as well so the formula to provide a prime for n = 1. If b = 2, then a has to be even.
            //
            // That cuts the possibilities of a by 50%. So we have limitied the total solution space by around a factor 12.
            int aMax = 0, bMax = 0, nMax = 0;
            _primes = Problem10.Problem10.ESieve(87400);
            int[] bPos = Problem10.Problem10.ESieve(1000);

            for (int a = -999; a < 1001; a += 2)
            {
                for (int i = 1; i < bPos.Length; i++)
                {
                    for (int j = 0; j < 2; j++)
                    {
                        int n = 0;
                        int sign = (j == 0) ? 1 : -1;
                        int aodd = (i%2 == 0) ? -1 : 0; // Making a even if b is even
                        while (IsPrime(Math.Abs(n*n + (a + aodd)*n + sign*bPos[i])))
                        {
                            n++;
                        }

                        if (n > nMax)
                        {
                            aMax = a;
                            bMax = bPos[i];
                            nMax = n;
                        }
                    }
                }
            }

            Console.WriteLine("A sequence of length "+nMax+", is generated by a="+aMax+", b="+bMax+", the product is "+(aMax*bMax));
            Console.ReadLine();
        }

        // Test for primality by using a binary search on a sorted array of primes
        public static bool IsPrime(int testNumber)
        {
            return Array.BinarySearch(_primes, testNumber) >= 0;
        }
    }
}
