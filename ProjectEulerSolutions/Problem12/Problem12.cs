using System;
namespace Problem12
{
    public class Problem12
    {
        static void Main()
        {
            // The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
            //
            // 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
            //
            // Let us list the factors of the first seven triangle numbers:
            //
            // 1: 1
            // 3: 1,3
            // 6: 1,2,3,6
            // 10: 1,2,5,10
            // 15: 1,3,5,15
            // 21: 1,3,7,21
            // 28: 1,2,4,7,14,28
            // We can see that 28 is the first triangle number to have over five divisors.
            //
            // What is the value of the first triangle number to have over five hundred divisors?
            //
            // The property we need in order to find an efficient method to derive the number of divisors of a number is based on the prime factorisation of the number which we dealt with in Problem
            // 3. Any number N is uniquely described by its prime factorisation.
            //
            // N = p1^a1 * p2^a2 * p3^a4 ... = n=1 -> K for pn^an
            //
            // Where pn is a distinct prime number, a(n) is the exponent of the prime and K is the set of all prime numbers less than or equal to the square root of N. Taking any unqiue combination
            // of the prime factors and multipluing them, will yield a unqie divisor of N. That means we can use combinatorics to determine the number of divisors based on the prime factorisation.
            // The prime p(n) can be chosen 0,1,....,a(n) times. That means in all we can choose p(n) in a(n) + 1 different ways.
            //
            // The total number of divisors of N, D(N) can be exressed as...
            // 
            // D(N) = (a1 + 1) * (a2 + 1) * (a3 + 1) ... = n = 1 -> K (a(n) + 1)
            //
            // Now we just need a function to carry out the factorisation.
            //
            // We used a prime factorisation in the solution to Problem 3, I have modified it to only use primes, instead of odd numbers, and I have modified it to actually count the divisors instead of
            // returning a divisor. You can check the function PrimeFactorisationNoD for the code.
            //
            // We can continue to improve this algorithm by decomposing the problem, into two smaller problems, which are significantly easier to solve. In problem 6, we established that the sum of natural
            // numbers can be written analytically, such that:
            //
            // N(k) = summation of j = 1 to k of n(j) = k(k + 1) / 2
            //
            // where N(k) is the kth triangle number.
            //
            // The property that we will use is that k and k + 1 are coprimes (which we als odealth with in Problem 9). You can convince your self of that in the general case of k, using Eclid's algorithm.
            // Since k and k + 1 are coprimes it means that their set of prime factors are distinct, and:
            //
            // D(N(k)) = D(k/2)D(k+1) if k is even and
            // D(N(k)) = D(k)D((k+1)/2) if k is odd
            //
            // In the first case, if k and k+1 are coprimes, so is k/2 and k+1, since 2 will be in the set of prime factors for k, and therefore not for k+1. Since otherwise they would not be coprimes. The
            // problem of factorisation has now been split into prime factorisation for two smaller numbers, which is a significantly easier task.
            //
            // Futhermore if we code it a bit smart like, we can reuse the prime factorisation for k+1 in the subsequent iteration, and thus we only need to factorise one number in each iteration.

            int number;
            int i = 2;
            int cnt = 0;
            int dn1 = 2;
            int dn = 2;
            int[] primelist = Problem10.Problem10.ESieve(1000);

            while (cnt < 500)
            {
                if (i%2 == 0)
                {
                    dn = PrimeFactorisationNoD(i + 1, primelist);
                    cnt = dn*dn1;
                }
                else
                {
                    dn1 = PrimeFactorisationNoD((i + 1)/2, primelist);
                    cnt = dn*dn1;
                }
                i++;
            }
            number = i*(i - 1)/2;

            Console.WriteLine("The first triangle number with over 500 digits is: "+number);
            Console.ReadLine();

            // Having tested this algorithm with up to 5,000 divisors I can safely say that this algorithm scales very well.
        }

        // This requires a list of primes. It starts at the lowest prime, and finds the exponent for that prime. Just as in Problem 3, if there the remainder reaches 1, there are no more divisors, and if
        // there is a left over, that left over will be a prime divisor as well.
        public static int PrimeFactorisationNoD(int number, int[] primelist)
        {
            int nod = 1;
            int exponent;
            int remain = number;

            for (int i = 0; i < primelist.Length; i++)
            {
                // In case there is a reminder this is a prime factor as well
                // The exponent of that factor is 1
                if (primelist[i]*primelist[i] > number)
                {
                    return nod*2;
                }

                exponent = 1;
                while (remain%primelist[i] == 0)
                {
                    exponent++;
                    remain = remain/primelist[i];
                }
                nod *= exponent;

                // If there is no remainder, return the count
                if (remain == 1)
                {
                    return nod;
                }
            }
            return nod;
        }
    }
}
